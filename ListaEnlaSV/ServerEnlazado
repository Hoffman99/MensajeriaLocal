#include <iostream>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <sys/select.h>
#include "ListaEnlazada.hpp"

using namespace std;

#define PUERTO 25565
#define TAM 1024
#define MAX_CLIENTES 1

int main() {
    Lista clientes;  
    int socket_servidor = socket(AF_INET, SOCK_STREAM, 0);
    if (socket_servidor < 0) {
        perror("Error al crear el socket");
        return 1;
    }

    sockaddr_in direccion;
    direccion.sin_family = AF_INET;
    direccion.sin_port = htons(PUERTO);
    direccion.sin_addr.s_addr = INADDR_ANY;

    if (bind(socket_servidor, (sockaddr*)&direccion, sizeof(direccion)) < 0) {
        perror("Error al hacer bind");
        return 1;
    }

    if (listen(socket_servidor, 5) < 0) {
        perror("Error en listen");
        return 1;
    }

    cout << "Servidor escuchando en el puerto " << PUERTO << endl;

    while (true) {
        fd_set lectura_fds;
        FD_ZERO(&lectura_fds);
        FD_SET(socket_servidor, &lectura_fds);
        int max_fd = socket_servidor;
        Nodo* actual = clientes.obtenerCabeza();
        while (actual != nullptr) {
            if (actual->dato.socket_fd != -1) {
                FD_SET(actual->dato.socket_fd, &lectura_fds);
                if (actual->dato.socket_fd > max_fd)
                    max_fd = actual->dato.socket_fd;
            }
            actual = actual->siguiente;
        }

        timeval timeout = {0, 50000}; 
        int actividad = select(max_fd + 1, &lectura_fds, NULL, NULL, &timeout);

        if (actividad < 0) {
            perror("Error en select");
            break;
        }

        if (FD_ISSET(socket_servidor, &lectura_fds)) {
            sockaddr_in cliente_dir;
            socklen_t cliente_len = sizeof(cliente_dir);
            int socket_cliente = accept(socket_servidor, (sockaddr*)&cliente_dir, &cliente_len);
            if(clientes.ObtenerCantidad()<MAX_CLIENTES){
                Cliente nuevoCliente;
                nuevoCliente.socket_fd = socket_cliente;
                if (socket_cliente >= 0) {
                    clientes.insertarAlFinal(nuevoCliente);
                    cout << "Nuevo cliente conectado: " << nuevoCliente.socket_fd << endl;
                    const char* bienvenida = "Â¡Bienvenido al servidor!";
                    send(nuevoCliente.socket_fd, bienvenida, strlen(bienvenida), 0);
                } else {
                    perror("Error al aceptar conexiÃ³n");
                }
            }else {
                cout << "Servidor lleno, rechazando conexiÃ³n." << endl;
                close(socket_cliente);
            }    
        }

        actual = clientes.obtenerCabeza();
        while (actual != nullptr) {
            if (actual->dato.socket_fd != -1 && FD_ISSET(actual->dato.socket_fd, &lectura_fds)) {
                ssize_t bytes = recv(actual->dato.socket_fd, actual->dato.mensaje, TAM, 0);
                if (bytes > 0) {
                    cout << "Cliente " << actual->dato.socket_fd << " dice: " << actual->dato.mensaje << endl;
                    Nodo* destinatario = clientes.obtenerCabeza();
                    while (destinatario != nullptr) {
                        if (destinatario->dato.socket_fd != 
                            actual->dato.socket_fd && 
                            destinatario->dato.socket_fd != -1) {
                            send(destinatario->dato.socket_fd, actual->dato.mensaje, strlen(actual->dato.mensaje), 0);
                        }
                        destinatario = destinatario->siguiente;
                    }
                    memset(actual->dato.mensaje, 0, TAM);
                } else if (bytes == 0 || bytes < 0) {
                    cout << "Cliente " << actual->dato.socket_fd << " desconectado.\n";
                    close(actual->dato.socket_fd);
                    clientes.eliminarNodo(actual->dato);  // ðŸ”¹ Eliminar cliente de la lista al desconectarse
                }
            }
            actual = actual->siguiente;
        }
    }

    close(socket_servidor);
    return 0;
}
